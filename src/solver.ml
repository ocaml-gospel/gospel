(**************************************************************************)
(*                                                                        *)
(*  GOSPEL -- A Specification Language for OCaml                          *)
(*                                                                        *)
(*  Copyright (c) 2018- The VOCaL Project                                 *)
(*                                                                        *)
(*  This software is free software, distributed under the MIT license     *)
(*  (as described in file LICENSE enclosed).                              *)
(**************************************************************************)

(** This module contains a typechecker that uses the Inferno library, which
    handles type inference. We first give definitions for program variables and
    types. We then feed these into the [Solver] functor which allows us to solve
    type constraints. *)

module X = Ident
module T = Types
module S = Structure
open Inferno
open Id_uast
open Tast
module Solver = Solver.Make (X) (S) (T)
open Solver
module W = Warnings

(** Deep type for functions *)
let deep_arrow arg ret =
  let f = S.ty_arrow arg ret in
  DeepStructure f

(** [map_binders f xs] is conceptually similar to [List.map], but creates a
    binder for each element in [xs]. This means an application of [f] may bind
    (and possibly return) inferno variables as well as applying some arbitrary
    transformation, as one would expect from [List.map]. This function returns a
    binder that introduces a list of all the values bound by applying [f] to
    every element in [xs]. *)
let rec map_binders (f : 'a -> ('b, 'r) binder) (xs : 'a list) :
    ('b list, 'r) binder =
 fun k ->
  match xs with
  | [] -> k []
  | x :: xs ->
      let@ y = f x in
      let@ l = map_binders f xs in
      k (y :: l)

(** [map_constraints f xs] is conceptually similar to [List.map], but creates a
    constraint for each element in [xs]. The resulting constraint is the
    conjunction of all constraints generated by applying [f] to all the values
    in [xs]. The semantic value of this constraint is a list of the semantic
    values of each constraint created by [f]. *)
let rec map_constraints (f : 'a -> 'b co) (xs : 'a list) : 'b list co =
  match xs with
  | [] -> pure []
  | x :: xs ->
      let+ xs' = map_constraints f xs and+ x' = f x in
      x' :: xs'

(* The following functions are used to turn Gospel signatures into Inferno
   constraints that, when solved, will produce typed signatures. If the
   constraint is unsatisfiable, then Inferno will produce an exception which we
   convert into an appropriate Gospel error. *)

(* All Inferno constraints have a semantic value associated with
   them. If a constraint is satisfiable, then Inferno will produce the
   associated sematic value. E.g. the [hastype] function produces a
   constraint whose semantic value is a typed term. This means if
   Inferno can solve the constraint, then it will build a typed
   term. *)

(** [pty_to_deep inferno_vars f t] maps the type [t] to a deep type. Since the
    translation of type variables depends on whether this is the type of a top
    level function or a type annotation for a local variable, this function
    allows the caller to supply an [f] to detail how to handle type variables.
*)
let rec pty_to_deep f pty =
  let pty_to_deep = pty_to_deep f in
  match pty with
  | PTtyvar id -> f id
  | PTtyapp (id, l) -> (
      match id.app_alias with
      | Some t -> pty_to_deep t
      | _ -> DeepStructure (S.Tyapp (id.app_qid, List.map pty_to_deep l)))
  | PTarrow (arg, ret) -> deep_arrow (pty_to_deep arg) (pty_to_deep ret)
  | PTtuple l -> DeepStructure (S.Tytuple (List.map pty_to_deep l))

(** [pty_to_deep_rigid pty] is a refinement of [pty_to_deep] where each type
    variable in [pty] becomes a rigid type variable i.e. this variable cannot be
    unified with any other type. *)
let pty_to_deep_rigid pty =
  deep (pty_to_deep (fun v -> DeepStructure (Tvar v)) pty)

(** [pty_to_deep_flex vars pty] is a refinement of [pty_to_deep] where each type
    variable in [pty] is mapped to the corresponding inferno variable in the
    associative list [vars]. This way, assuming that all the inferno variables
    in [vars] are flexible, the type variables in the resulting deep type can be
    unified with any other type *)
let pty_to_deep_flex vars pty =
  deep (pty_to_deep (fun v -> DeepVar (List.assoc v.id_tag vars)) pty)

(** [assoc_vars vars] returns a binder for a list where every type variable in
    [vars] is associated with a fresh Inferno type variable. *)
let assoc_vars vars =
  let f var k =
    let@ v = exist in
    k (var.Ident.id_tag, v)
  in
  map_binders f vars

(** [record_ty env rfid] returns a binder that introduces the record type that
    the record label [rfid] belongs to as well as the type variables in the
    record type. *)
let record_ty params rid =
 fun k ->
  let@ vars = assoc_vars params in
  let@ ty = shallow (S.Tyapp (Qid rid, List.map snd vars)) in
  k (vars, ty)

(** [field_pty vars q t ty] returns a binder that introduces [q], [t] and an
    inferno type variable whose value is equal to [ty]. *)
let field_pty vars q t ty =
 fun k ->
  let@ ty = pty_to_deep_flex vars ty in
  k (q, t, ty)

(** [top_level_pty env id] returns a binder that introduces the type of the top
    level function [id]. *)
let top_level_pty params ty =
 fun k ->
  (* Associate each type variable in [params] with a flexible inferno
      variable. *)
  let@ vars = assoc_vars params in
  (* Turn the type [ty] into an inferno type variable *)
  let@ ty = pty_to_deep_flex vars ty in
  k (ty, List.map snd vars)

(** [binder_to_deep pty] If [pty] is not [Some t], creates an Inferno variable
    that is equal to [t]. If not, create an unconstrained inferno variable *)
let pty_opt_to_deep = function
  | None ->
      fun k ->
        let@ v = exist in
        let annot = decode v in
        k (v, annot)
  | Some ty ->
      fun k ->
        let@ v = pty_to_deep_rigid ty in
        k (v, pure ty)

(** [ids_of_pat pat] returns a binder for an associative list that maps
    identifier tags with their respective inferno variables. *)
let rec ids_of_pat pat k =
  match pat.Id_uast.pat_desc with
  | Pwild -> k []
  | Pid id ->
      let@ v = exist in
      k [ (id.id_tag, (id, v)) ]
  | Ptuple l ->
      let@ l = map_binders ids_of_pat l in
      k (List.concat l)
  | Pcast (p, _) -> ids_of_pat p k

(** [pat_to_deep ids pat] returns a binder for a pair of an inferno variable for
    a type that matches the pattern and a constraint for the pattern. *)
let rec pat_desc_to_deep ids pat k =
  match pat.Id_uast.pat_desc with
  | Pwild ->
      let@ v, _ = pty_opt_to_deep None in
      k (v, pure Tast.Pwild)
  | Pid id ->
      let _, v = List.assoc id.id_tag ids in
      let pat =
        let+ annot = decode v in
        Pid (mk_ts id annot)
      in
      k (v, pat)
  | Ptuple l ->
      let@ l = map_binders (pat_to_deep ids) l in
      let vl, pl = List.split l in
      let@ v = shallow (S.Tytuple vl) in
      let pat =
        let+ l = map_constraints (fun x -> x) pl in
        Tast.Ptuple l
      in
      k (v, pat)
  | Pcast (p, ty) ->
      let@ v, c = pat_to_deep ids p in
      let loc = pat.pat_loc in
      let c =
        Solver.correlate (loc.loc_start, loc.loc_end)
        @@
        let@ ty_var = pty_to_deep_rigid ty in
        let+ pat = c and+ () = ty_var -- v in
        Pcast (pat, ty)
      in
      k (v, c)

and pat_to_deep ids p =
 fun k ->
  let@ v, c = pat_desc_to_deep ids p in
  let c =
    let+ pat_desc = c in
    { pat_desc; pat_loc = p.pat_loc }
  in
  k (v, c)

(** [build_def vars c] Creates a constraint that adds the variables in [vars] to
    the scope of constraint [c] via a chain of [def] constraints. *)
let build_def vars c =
  List.fold_right
    (fun tid c ->
      let@ ty = pty_to_deep_rigid tid.ts_ty in
      def tid.ts_id ty c)
    vars c

(** [build_def_opt vars c] Returns a constraint where the variables in [l] have
    been added to the scope of constraint [c] by means of a chain of [def]
    constraints.

    Each element of [vars] is a pair consisting of an identifier [x] and its
    type annotation. If [None], then the user did not supply one and we
    associate it with a flexible Inferno type variable.

    The semantic value of the returned constraint is the semantic value of [c]
    coupled with the list of bound variables and their types. This list is
    identical to [vars] except that all [None] values have been replaced with
    the inferred type. *)
let build_def_opt vars c =
  (* [loop (id, ty_annot) c] creates a constraint stating that
     variable [id] has type [ty_annot] in constraint [c]. The semantic
     value of this constraint is the same as [c], except we add the
     variable [id] and coupled with its inferred type to the returned
     list. *)
  let loop (id, ty_annot) c =
    let@ ty_res, annot = pty_opt_to_deep ty_annot in
    let+ annot = annot and+ l, t = def id ty_res c in
    (mk_ts id annot :: l, t)
  in
  (* Map the constraint [c] to one where the semantic value is a pair whose
     first element is an empty list and the second is the semantic value of [c]
     so we can build the list of typed arguments while keeping the previous
     value unchanged. *)
  let acc =
    let+ t = c in
    ([], t)
  in
  List.fold_right loop vars acc

(** [fold_binders f l r] is effectively a [List.fold_right] but the accumulating
    function returns a binder. *)
let fold_right_binders f l r =
  List.fold_right
    (fun x r k ->
      let@ r = r in
      let@ r = f x r in
      k r)
    l
    (fun k -> k r)

(** [hastype ts t r] receives an untyped term [t] and the expected type [r] and
    produces a constraint whose semantic value is a typed term. The environment
    [ts] is used to ensure that all type annotations are valid. *)
let rec hastype (t : Id_uast.term) (r : variable) =
  (* This line ensures that Inferno errors refer to the correct code
     fragment. *)
  Solver.correlate (t.term_loc.loc_start, t.term_loc.loc_end)
  @@
  let+ t_node =
    match t.term_desc with
    | Id_uast.Ttrue ->
        (* For true and false, we state that the expected type is
           bool *)
        let+ () = r --- S.ty_bool in
        Ttrue
    | Tfalse ->
        let+ () = r --- S.ty_bool in
        Tfalse
    | TTrue ->
        (* For True and False (capitalized) we state that the expected
           type is prop *)
        let+ () = r --- S.ty_prop in
        TTrue
    | TFalse ->
        let+ () = r --- S.ty_prop in
        TFalse
    | Tconst constant ->
        (* Depending on the type of constant, we restrict the expected type
            accordingly *)
        let+ () =
          match constant with
          | Pconst_integer _ -> r --- S.ty_integer
          | Pconst_char _ -> r --- S.ty_char
          | Pconst_string _ -> r --- S.ty_string
          | Pconst_float _ -> r --- S.ty_float
        in
        Tconst constant
    | Tlocal id ->
        (* If the variable is defined within the scope of this term,
            we create a constraint stating that the variable [id]
            must be an instance of type [r]. No lookup is performed
            as the bookkeeping is done by Inferno. *)
        let+ _ = instance id r in
        (* We can ignore the return value of [instance] since it will always
            return the empty list since all local variables are bound with
            [def], which creates a monomorphic scheme. *)
        Tvar (Qid id)
    | Tvar (q, params, pty) ->
        (* In the case of a top level definition outside the scope of this term,
            we use the type provided during the name resolution stage. *)
        let@ ty, l = top_level_pty params pty in
        let+ () = r -- ty and+ ptys = map_constraints decode l in
        (* If the type of this variable uses any flexible inferno type
           variables that were not unified, then we create an explicit
           application of [q] to the types it receives as argument. *)
        if params = [] then Tvar q else Ttyapply (q, ptys)
    | Tlet (pat, t1, t2) ->
        (* let id1, id2, ... = t1 in t2 *)
        (* Associative list that maps each identifier in [pat] to an
            inferno variable. *)
        let@ ids = ids_of_pat pat in
        let@ v_type, pat = pat_to_deep ids pat in
        let+ t1 = hastype t1 v_type
        and+ t2 =
          (* Create a constraint for the term [t2] where we add to
              the scope every variable in [ids]. *)
          let t2 = hastype t2 r in
          List.fold_left (fun r (_, (id, v)) -> def id v r) t2 ids
        and+ pat = pat in
        Tlet (pat, t1, t2)
    | Tapply (t1, t2) ->
        (* t1 t2 (Function application)*)
        (* Inferno variables for the function's argument and return type. *)
        let@ arg_ty = exist in
        let@ res = exist in
        (* The term [t1] must be of the function type [arg_ty -> r]. *)
        let+ t1 = lift hastype t1 (S.ty_arrow arg_ty res)
        (* The argument [t2] has some type [arg_ty]. *)
        and+ t2 = hastype t2 arg_ty
        (* The return value of the term has the same type of the return value of
            the function.

            Note: Although [res] could be inlined with [r] with no functional
            difference in terms of typechecking, doing it this way forces Inferno
            to first solve the previous two constraints meaning we will get a more
            precise error message when the return type is invalid. If this is
            unclear, try replacing [res] with [r] and see what happens. *)
        and+ () = r -- res in
        Tapply (t1, t2)
    | Tquant (q, l, t) ->
        (* forall. x y z. t *)
        (* The term [t] must be a formula *)
        let c = lift hastype t S.ty_prop in
        (* Transform the list of Gospel type annotation into a list of
            Inferno binders *)
        let+ l, t = build_def_opt l c in
        Tquant (q, l, t)
    | Tif (g, then_b, else_b) ->
        (* if g then then_b else else_b *)
        (* The guard must have type [bool] *)
        let+ g = lift hastype g S.ty_bool
        (* Both branches must have the return type [r] *)
        and+ then_b = hastype then_b r
        and+ else_b = hastype else_b r in
        Tif (g, then_b, else_b)
    | Ttuple l ->
        (* Given a term [t], returns a binder that returns a fresh Inferno
            variable [v] and a constraint stating that the type of the term is
            [v]. *)
        let f t =
         fun k ->
          let@ v = exist in
          k (hastype t v, v)
        in

        (* Creates a constraint and a variable for each term in the tuple *)
        let@ vars = map_binders f l in

        (* Joins all the constraints in [vars] into a single constraint *)
        let+ l = map_constraints fst vars
        (* The return type must be equal to the type of the tuple *)
        and+ () = r --- Tytuple (List.map snd vars) in
        Ttuple l
    | Tlambda (args, t, pty) ->
        (* The return of the function as an inferno variable *)
        let@ res, annot = pty_opt_to_deep pty in
        (* The function's type as an inferno variable. *)
        let@ all_ids, args, ty_fun =
          fold_right_binders
            (fun arg (all_ids, args, r) k ->
              let@ ids = ids_of_pat arg in
              let@ v, pat = pat_to_deep ids arg in
              let@ x = shallow (S.Tyarrow (v, r)) in
              k (ids @ all_ids, pat :: args, x))
            args ([], [], res)
        in
        let c = hastype t res in
        (* Build a constraint with all the function's arguments in
            scope. *)
        let+ () = r -- ty_fun
        and+ t = List.fold_left (fun c (_, (v, id)) -> def v id c) c all_ids
        and+ annot_ty = annot
        and+ args = map_constraints (fun x -> x) args in
        Tlambda (args, t, Option.map (fun _ -> annot_ty) pty)
    | Trecord (l, rec_ty) ->
        (* Gets the record type as well as the list of type parameters used as
            inferno variables. *)
        let@ vars, r_ty = record_ty rec_ty.params rec_ty.name in
        (* Get the expected type of each record label. *)
        let@ tys = map_binders (fun (q, t, ty) -> field_pty vars q t ty) l in
        (* Associate each field instantiation with its expected type *)
        let check_field (q, t, v) =
          let+ t = hastype t v in
          (q, t)
        in
        let+ l = map_constraints check_field tys and+ () = r -- r_ty in
        Trecord l
    | Tfield (t, rec_ty, field, ty) ->
        (* Get the type for the record which [field] belongs to. *)
        let@ vars, r_ty = record_ty rec_ty.params rec_ty.name in
        (* Get the type of the field. *)
        let@ ty = pty_to_deep_flex vars ty in
        (* The term [t] must be of the type of the record which [t] belongs
            to. Additionally, the type of this term must be equal to the type of
            the field. *)
        let+ t = hastype t r_ty and+ () = r -- ty in
        Tfield (t, field)
    | Tattr (s, t) ->
        let+ t = hastype t r in
        Tattr (s, t)
    | Tcast (t, ty) ->
        (* Turn the type annotation into a deep type. *)
        let@ ty_var = pty_to_deep_rigid ty in
        let+ t = hastype t r
        (* Ensure that the type annotation corresponds with the type of the
            term. *)
        and+ () = r -- ty_var in
        Tcast (t, ty)
    | Tscope (q, t) ->
        (* Since name resolution has already been handled, we can safely ignore
            local scopes. *)
        let+ t = hastype t r in
        Tscope (q, t)
    | Told t ->
        let+ t = hastype t r in
        Told t
  (* By calling [decode], we can get the inferred type of the term. *)
  and+ t_ty = decode r in
  mk_term t_node t_ty t.term_loc

(** Solves an arbitrary constraint assuming types are not allowed to be
    recursive *)
let typecheck tvars c =
  Types.add_tvars tvars;
  try
    let t = snd (Solver.solve ~rectypes:false (let0 c)) in
    let l = Types.clear_tvars () in
    (t, l)
  with
  | Solver.Unify (loc, ty1, ty2) -> Types.incompatible_types loc ty1 ty2
  | Solver.Cycle (loc, pty) -> Types.cycle loc pty
  | Solver.Unbound _ -> assert false
  (* Unbound variables are caught before we run the solver *)
  | Solver.VariableScopeEscape _ -> assert false
(* This exception is only thrown when using rigid Inferno variables. *)

let fmla t =
  let@ ty = shallow S.ty_prop in
  hastype t ty

let int_term t =
  let@ ty = shallow S.ty_integer in
  hastype t ty

let fspec_constraint f =
  let+ pre = map_constraints fmla f.Id_uast.fun_req
  and+ post = map_constraints fmla f.Id_uast.fun_ens
  and+ variant = map_constraints int_term f.fun_variant in
  mk_fun_spec pre post variant f.fun_text f.fun_loc

let invariant_constraint id ty inv =
  let t = fmla inv in
  let@ ty = pty_to_deep_rigid ty in
  def id ty t

(** [function_cstr ts f] Creates a constraint whose semantic value is a list of
    signatures whose head is the declaration of the function described by [f].
    This is the conjunction of two constraints: one that checks if the body of
    the function is well typed and another that checks if the function's
    specification is well typed. *)
let function_cstr (f : Id_uast.function_) : (Tast.function_ * Id_uast.pty) co =
  (* Turn the return type into a deep type *)
  let ret_pty = Option.value ~default:Types.ty_prop f.fun_type in
  let arrow_ty =
    List.fold_right
      (fun (_, pty) acc -> PTarrow (pty, acc))
      f.fun_params ret_pty
  in

  let@ ret_ty = pty_to_deep_rigid ret_pty in

  (* The function type encoded as a deep type *)
  let@ fun_ty = pty_to_deep_rigid arrow_ty in

  (* Typecheck the body of the function. Must have the same return
     type that the user indicated. *)
  let body_c =
    match f.fun_def with
    | None -> pure None
    | Some t ->
        let c = hastype t ret_ty in
        let+ tt =
          if f.fun_rec then
            (* If the function is recursive, it must be defined within
               the scope of the term. *)
            def f.fun_name fun_ty c
          else c
        in
        Some tt
  in
  (* Combines the constraint for the function body and the constraint for the
     specification. This way, they can be solved under the same chain of [def]
     constraints. *)
  let fco =
    let+ body = body_c and+ spec = fspec_constraint f.fun_spec in
    (body, spec)
  in

  (* Function parameters, typed term and typed function specification. *)
  let params = List.map (fun (x, t) -> mk_ts x t) f.fun_params in
  let+ tt, fun_spec = build_def params fco in
  let f = mk_function f params tt ret_pty fun_spec in
  (f, arrow_ty)

(** Creates a constraint ensuring the term within an axiom has type [prop]. *)
let axiom_cstr ax =
  let+ t = fmla ax.Id_uast.ax_term in
  mk_axiom ax.ax_name t ax.ax_loc ax.ax_text

(** [sp_var arg] turns a value of type [sp_var] into a [tsymbol]. If [arg] is an
    unnamed variable, return [None]. *)
let sp_var = function
  | Ghost (id, pty) -> Some (mk_ts id pty)
  | OCaml v ->
      let id = match v.var_name with Qid id -> id | _ -> assert false in
      Option.map (mk_ts id) v.ty_gospel
  | _ -> None

let xspec (spec : Id_uast.xpost_spec) =
  let spec_cstr =
    let+ sp_xpost = map_constraints fmla spec.sp_xpost in
    mk_xpost spec.sp_exn spec.sp_xargs spec.sp_xrets spec.sp_xtops sp_xpost
      spec.sp_xloc
  in
  let args = List.filter_map sp_var spec.sp_xargs in
  let rets = List.filter_map sp_var spec.sp_xrets in
  build_def (args @ rets) spec_cstr

(** Creates a constraint ensuring that the terms within [pre] and [post] are
    well typed. *)
let spec_cstr (spec : Id_uast.val_spec) =
  (* Constraint that solves each pre and post condition. *)
  let spec_cstr =
    let+ sp_pre = map_constraints fmla spec.sp_pre
    and+ sp_post = map_constraints fmla spec.sp_post
    and+ sp_checks = map_constraints fmla spec.sp_checks
    and+ xpost_spec = map_constraints xspec spec.sp_xpost in
    Tast.mk_vspec spec.sp_args spec.sp_rets spec.sp_tops sp_pre sp_post
      sp_checks xpost_spec spec.sp_diverge spec.sp_pure spec.sp_text spec.sp_loc
  in
  let args = List.filter_map sp_var spec.sp_args in
  let rets = List.filter_map sp_var spec.sp_rets in

  (* Remark: Return values are added to the scope of both the pre and
     post conditions, although return values are not allowed to be
     used in the former.  This is fine since we have already performed
     name resolution before calling the solver meaning that this case
     will never happen. *)
  build_def (args @ rets) spec_cstr

let axiom tvars ax =
  let ax, vars = typecheck tvars (axiom_cstr ax) in
  { ax with ax_tvars = tvars @ vars }

let function_ tvars f =
  let (f, pty), vars = typecheck tvars (function_cstr f) in
  ({ f with fun_tvars = tvars @ vars }, pty)

let spec tvars spec =
  let spec, vars = typecheck tvars (spec_cstr spec) in
  (spec, vars)

let invariant tvars id ty inv =
  (* TODO: What to do about type variables defined in type invariants. *)
  let t, _ = typecheck tvars (invariant_constraint id ty inv) in
  t
